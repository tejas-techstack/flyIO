// TODO 
//
// right now read requests coming from the client is not handled properly this needs to be fixed
// SEE HOW TO USE SyncRPC


package main

import (
  "encoding/json"
  "context"
  "log"
  "os"
  "sync"

	maelstrom "github.com/jepsen-io/maelstrom/demo/go"
)

func main(){
  n := maelstrom.NewNode()

  // define a nodeState and set it initially to normal
  nodeState := "normal"

  // define a nodeConCount that is intended to track the nodes that are currently connected.
  nodeConCount := 0

  // define the local storage for the node.
  var local_storage []any

  // accept the topology but do nothing with it
  n.Handle("topology", func(msg maelstrom.Message) error {
    return n.Reply(msg, map[string]any{"type":"topology_ok",})
  })

  // accept read request
  n.Handle("read", func(msg maelstrom.Message) error {
    var body map[string]any
    if err := json.Unmarshal(msg.Body, &body);err != nil{
      return err
    }

    if body["fromnode"] != true {
      return n.Reply(msg, map[string]any{"type": "read_ok", "messages": local_storage,})
    }

    if body["setnormal"] == true {
      nodeState = "normal"
      return n.Reply(msg, map[string]any{"type": "read_ok", "messages": local_storage,})
    }

    // TODO if the node sends these as new go routines and immediatly sends a reply back to the
    // client saying broadcast_ok then we will have a problem.
    for _, v := range n.NodeIDs(){
      if v == n.ID(){
        continue
      }

      respCh := make(chan maelstrom.Message)
      errorCh := make(chan error)
      go func() {
        ping_reply_chan, err := n.SyncRPC(context.Background(), v, map[string]any{"type":"ping",})
        if err != nil{
          errorCh <- err;
        } else {
          respCh <- ping_reply_chan
        }

        if err := <- errorCh; err != nil{
          log.Println("Yea no reply cuz", err)
          return
        }

        ping_reply := <-respCh
        var pong map[string]any

        if err := json.Unmarshal(ping_reply.Body, &pong); err != nil{
          log.Println("json not unmarshaled cuz", err)
          return
        }
        if pong["message"] == "pong"{
          nodeConCount++
        }
      }()

    }


    log.Println("NodeConCount after pinging all nodes:", nodeConCount)
    // check the output of the pings and change state based on it
    if nodeConCount < len(n.NodeIDs()) {
      nodeState = "partitioned"
    } else {
      if (nodeConCount == len(n.NodeIDs()) && nodeState == "partitioned"){
        nodeState = "recovering"
      }
    }
    // end of ping and state change
    nodeConCount = 0;


    // based on state do different things
    switch nodeState{

      // if partitioned or normal then the reply is simply local storage
      case "partitioned", "normal":
        log.Println("RETURNING FROM PARTITION/NORMAL STATE")
        return n.Reply(msg, map[string]any{"type": "read_ok", "messages": local_storage,})
      
      // if recovering then make sure the nodes recover and then send the proper data
      case "recovering":

        // the first for loop reads from all nodes and stores the data
        for _, node_rec_read := range n.NodeIDs(){
          if node_rec_read == n.ID(){
            continue
          }
          n.RPC(node_rec_read, map[string]any{"type": "read", "setnormal": true,"fromNode": true,}, func (readReply maelstrom.Message) error {
            var reply map[string]any
            if err := json.Unmarshal(readReply.Body, &reply); err != nil{
              return err
            }

            var mu sync.Mutex
            mu.Lock()

            for _, vals := range (body["messages"].([]any)){
              local_storage = append(local_storage, vals)
            }

            mu.Unlock()

            return nil
          })
        }

        // once all the data is retrieved broadcast the entire data to all nodes
        for _, node_rec_reply := range n.NodeIDs(){
          if node_rec_reply == n.ID(){
            continue
          }
          n.Send(node_rec_reply, map[string]any{"type": "recover", "setnil" : true, "message" : local_storage,})
        }
        
        nodeState = "normal"
        log.Println("RETURNING FROM RECOVER STATE")
        return n.Reply(msg, map[string]any{"type": "read_ok", "messages" : local_storage,})
    }

    // fall back on sending the local storage to client
    log.Println("FELL ONTO FALLBACK - READ")
    return n.Reply(msg, map[string]any{"type": "read_ok", "messages": local_storage,})
  })
  
  // handle broadcast request and reply with "broadcast_ok"
  n.Handle("broadcast", func(msg maelstrom.Message) error {
    var body map[string]any
    if err := json.Unmarshal(msg.Body, &body); err != nil{
      return err
    }

    local_storage = append(local_storage, body["message"])

    // TODO if the node sends these as new go routines and immediatly sends a reply back to the
    // client saying broadcast_ok then we will have a problem.

    // var wg sync.WaitGroup
    for _, v := range n.NodeIDs(){
      if v == n.ID(){
        continue
      }

      respCh := make(chan maelstrom.Message)
      errorCh := make(chan error)
      // wg.Add(1)
      go func() {
        // defer wg.Done()
        ping_reply_chan, err := n.SyncRPC(context.Background(), v, map[string]any{"type":"ping",})
        if err != nil{
          errorCh <- err;
        } else {
          respCh <- ping_reply_chan
        }

        if err := <- errorCh; err != nil{
          log.Println("yea node crashed in bc cuz:", err)
          return
        }

        ping_reply := <-respCh
        var pong map[string]any

        if err := json.Unmarshal(ping_reply.Body, &pong); err != nil{
          log.Println("json not unmarshaled cuz:", err)
          return
        }
        if pong["message"] == "pong"{
          nodeConCount++
        }
      }()

      // wg.Wait()
    }

    if nodeConCount < len(n.NodeIDs()) {
      nodeState = "partitioned"
    } else {
      if (nodeConCount == len(n.NodeIDs()) && nodeState == "partitioned"){
        nodeState = "recovering"
      }
    }
    // end of pinging nodes and checking state.
    
    nodeConCount = 0;
    
    
    switch nodeState{
      
      // handle partitioned state
      case "partitioned":
        log.Println("RETURNING FROM PARTITIONED STATE")
        return n.Reply(msg, map[string]any{"type":"broadcast_ok",})

      // handle normal state
      case  "normal":
        for _, node_unicast := range n.NodeIDs(){
          if node_unicast == n.ID(){
            continue
          }
          n.Send(node_unicast, map[string]any{"type": "unicast", "message": body["message"],})
        }

        log.Println("RETURNING FROM NORMAL STATE")
        return n.Reply(msg, map[string]any{"type":"broadcast_ok",})

      // handle recovering state
      case "recovering":
        for _, node_rec_read := range n.NodeIDs(){
          if node_rec_read == n.ID(){
            continue
          }
          n.RPC(node_rec_read, map[string]any{"type": "read", "setnormal": true, "fromnode": true,}, func (readReply maelstrom.Message) error {
            var reply map[string]any
            if err := json.Unmarshal(readReply.Body, &reply); err != nil{
              return err
            }

            var mu sync.Mutex
            mu.Lock()

            for _, vals := range (body["messages"].([]any)){
              local_storage = append(local_storage, vals)
            }

            mu.Unlock()

            return nil
          })
        }

        for _, node_rec_reply := range n.NodeIDs(){
          if node_rec_reply == n.ID(){
            continue
          }
          n.Send(node_rec_reply, map[string]any{"type": "recover", "setnil" : true, "message" : local_storage,})
        }
        
        nodeState = "normal"
        log.Println("RETURNING FROM RECOVERING STATE")
        return n.Reply(msg, map[string]any{"type" : "broadcast_ok",})
    }

    log.Println("FELL ONTO FALLBACK - BROADCAST")
    return n.Reply(msg, map[string]any{"type" : "broadcast_ok",})
  })


  n.Handle("recover", func(msg maelstrom.Message) error {
    var body map[string]any
    if err := json.Unmarshal(msg.Body, &body); err != nil{
      return err
    }

    local_storage = nil

    local_storage = (body["message"].([]any));

    return nil
  })


  // handle ping
  n.Handle("ping", func(msg maelstrom.Message) error {
    return n.Reply(msg, map[string]any{"message": "pong",})
  })

  // handle unicast message
  n.Handle("unicast", func(msg maelstrom.Message) error {
    var body map[string]any
    if err := json.Unmarshal(msg.Body, &body); err != nil{
      return err
    }

    local_storage = append(local_storage, body["message"])

    return nil
  })

    // Run the node
  if err := n.Run(); err != nil{
      log.Fatal(err)
      os.Exit(1)
  }
}

